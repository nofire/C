#include "simuc.h"
#include "io_treiber.h"

#define wait_for_return
//#include "dsclib.h"

typedef struct BHandle_Data {
	BYTE Board_allocated;	// 1=allocated, 0=free
	BYTE Port_A_Direction;	// 1=Output, 0=Input
	BYTE Port_B_Direction;
	BYTE Port_C_Direction;
	BYTE Port_D_Direction;
} BHandle;

unsigned short int portvalue, help;

BHandle BoardHandle_Data;
DSCB GlobalBoardHandle = &BoardHandle_Data;

BYTE Init(DSCB BoardHandle, unsigned long int Steuerwort) {
    BYTE Board_allocated;

    BYTE Port_A_Direction = Steuerwort & 0b00000001; // PA 0 = 0x90;
    BYTE Port_B_Direction = Steuerwort & 0b00000010; // PB 1 = 0x82;
    BYTE Port_C_Direction = Steuerwort & 0b00000100; // PC 2 = 0x88;
    BYTE Port_D_Direction = Steuerwort & 0b00001000; // PD 3 = 0x81;


    /*Ports 0,1,3,4 auslesen*/
    switch(Steuerwort){

        case PA:                                                           // Eingang Port A
            if(Port_A_Direction){
                io_out16(DIR1,0x0000);
                io_out16(DIR0,0xFFFF);
                Board_allocated  = 1;
                Port_A_Direction = 0;
                Port_B_Direction = 1;
                Port_C_Direction = 1;
                Port_D_Direction = 1;
                break;
        }


        case PB:                                                            // Eingang Port B
            if(Port_B_Direction){
                io_out16(DIR1,0x0000);
                io_out16(DIR0,0xFFFF);
                Board_allocated  = 1;
                Port_A_Direction = 1;
                Port_B_Direction = 0;
                Port_C_Direction = 1;
                Port_D_Direction = 1;
                break;
            }


        case PC:                                                            // Eingang Port C
            if(Port_C_Direction){
                io_out16(DIR1,0x0000);
                io_out16(DIR0,0xFFFF);
                Board_allocated  = 1;
                Port_A_Direction = 1;
                Port_B_Direction = 1;
                Port_C_Direction = 0;
                Port_D_Direction = 1;
                break;
            }


        case PD:                                                             // Eingang Port D
            if(Port_D_Direction){
                io_out16(DIR1,0x0000);
                io_out16(DIR0,0xFFFF);
                Board_allocated  = 1;
                Port_A_Direction = 1;
                Port_B_Direction = 1;
                Port_C_Direction = 1;
                Port_D_Direction = 0;
            break;
            }
        }

    return 0;
}

BYTE InputByte(DSCB BoardHandle, BYTE Port, BYTE *DigitalValue) {
	
unsigned long int Steuerwort, help;

    // Eingang Port 1
    switch(Port){

    case PA:   // Einlesen eines Bytes von Port B
        if (InputByte(BoardHandle, PA, &help) != 0){
            putstring("Byte konnte nicht von Port A gelesen werden\n");
            wait_for_return;
            return(-1);
        }else if(InputByte(BoardHandle, PA, &help) == 0){
            putstring("Byte konnte von Port A gelesen werden\n");
            portvalue = (portvalue)&0xFF;
            *DigitalValue = portvalue;
            return *DigitalValue;
        }
    break;

    case PB:
        if (InputByte(BoardHandle, PB, &help) != 0){
            putstring("Byte konnte nicht von Port B gelesen werden\n");
            wait_for_return;
            return(-1);
        } else if(InputByte(BoardHandle, PB, &help) == 0){
            putstring("Byte konnte von Port B gelesen werden\n");
            portvalue = (portvalue >> 8)&0xFF;
            *DigitalValue = portvalue;
            return *DigitalValue;
        }
    break;

    case PC:
        if (InputByte(BoardHandle, PC, &help) != 0){
            putstring("Byte konnte nicht von Port C gelesen werden\n");
            wait_for_return;
            return(-1);
        }else if(InputByte(BoardHandle, PC, &help) == 0){
            putstring("Byte konnte nicht von Port C gelesen werden\n");
            //portvalue = io_in16(IN);
            portvalue = (portvalue)&0xFF;
            *DigitalValue = portvalue;

          return(*DigitalValue);
    break;

    case PD:
        if (InputByte(BoardHandle, PD, &help) != 0){
            putstring("Byte konnte nicht von Port D gelesen werden\n");
            wait_for_return;
            return(-1);
        }else if(InputByte(BoardHandle, PD, &help) == 0){
            putstring("Byte konnte nicht von Port D gelesen werden\n");
            //   portvalue = io_in16(IN);
            portvalue = (portvalue >> 8)&0xFF;
            DigitalValue = portvalue;

            return(*DigitalValue);
            }

    break;
    }
}

}
    // 1 -> ungültiger BoardHandle
    // 2 -> ungültiger Port




BYTE OutputByte(DSCB BoardHandle, BYTE Port, BYTE DigitalValue) {
	
    unsigned long int Steuerwort;
    switch(Port){

    case PB:
        // Port B --> dualen Zahlenwert, bits 15-8 des Port 0 anliegt, mittels DigitalValue zurück liefern




    case PA:
        // Port A --> dualen Zahlenwert, bits 7-0 des Port 0 anliegt, mittels DigitalValue zurück liefern

        // Ausgabe des eingelesenen Bytes auf Port A
        if (OutputByte(BoardHandle, PA, help) != 0){
            putstring("Byte konnte nicht ausgegeben werden\n");
            wait_for_return;
            return(-1);
        }else if(OutputByte(BoardHandle, PA, help) != 0){
            io_out16(DIR1,0x0000);
            portvalue = (portvalue<<8) &0xFF;
            return 0;
        }return 2;
    }

    // 2 -> ungültiger Port
    // 3 -> es wurde versucht etwas auf einen als Eingang konfigurierten Port auszugeben

    return 0; // 0 -> kein Fehler

}

BYTE Free(DSCB BoardHandle) {

    // 1 -> ungültiger BoardHandle
	
    return 0;

}

