#include "simuc.h"
#include "io_treiber.h"

#define wait_for_return
//#include "dsclib.h"

typedef struct BHandle_Data {
	BYTE Board_allocated;	// 1=allocated, 0=free
	BYTE Port_A_Direction;	// 1=Output, 0=Input
	BYTE Port_B_Direction;
	BYTE Port_C_Direction;
	BYTE Port_D_Direction;
} BHandle;

unsigned short int portvalue;

BHandle BoardHandle_Data;
DSCB GlobalBoardHandle = &BoardHandle_Data;

BYTE Init(DSCB BoardHandle, unsigned long int Steuerwort) {
    BYTE Board_allocated;

    BYTE Port_A_Direction = Steuerwort & 0b00000001; // PA 0 = 0x90;
    BYTE Port_B_Direction = Steuerwort & 0b00000010; // PB 1 = 0x82;
    BYTE Port_C_Direction = Steuerwort & 0b00000100; // PC 2 = 0x88;
    BYTE Port_D_Direction = Steuerwort & 0b00001000; // PD 3 = 0x81;


    /*Ports 0,1,3,4 auslesen*/
    switch(Steuerwort){

        case PA:                                                           // Eingang Port A
            if(Port_A_Direction){
                io_out16(DIR1,0x0000);
                io_out16(DIR0,0xFFFF);
                Board_allocated  = 1;
                Port_A_Direction = 0;
                Port_B_Direction = 1;
                Port_C_Direction = 1;
                Port_D_Direction = 1;
                break;
        }


        case PB:                                                            // Eingang Port B
            if(Port_B_Direction){
                io_out16(DIR1,0x0000);
                io_out16(DIR0,0xFFFF);
                Board_allocated  = 1;
                Port_A_Direction = 1;
                Port_B_Direction = 0;
                Port_C_Direction = 1;
                Port_D_Direction = 1;
                break;
            }


        case PC:                                                            // Eingang Port C
            if(Port_C_Direction){
                io_out16(DIR1,0x0000);
                io_out16(DIR0,0xFFFF);
                Board_allocated  = 1;
                Port_A_Direction = 1;
                Port_B_Direction = 1;
                Port_C_Direction = 0;
                Port_D_Direction = 1;
                break;
            }


        case PD:                                                             // Eingang Port D
            if(Port_D_Direction){
                io_out16(DIR1,0x0000);
                io_out16(DIR0,0xFFFF);
                Board_allocated  = 1;
                Port_A_Direction = 1;
                Port_B_Direction = 1;
                Port_C_Direction = 1;
                Port_D_Direction = 0;
            break;
            }
        }

    return 0;
}

BYTE InputByte(DSCB BoardHandle, BYTE Port, BYTE *DigitalValue) {
	
unsigned long int Steuerwort;

    BYTE Port_C_Direction = Steuerwort & 0b00000100; // PC 2 = 0x88;
    BYTE Port_D_Direction = Steuerwort & 0b00001000; // PD 3 = 0x81;


    // Eingang Port 1
    switch(Port){

    case PD:
        // Port D --> dualen Zahlenwert, bits 15-8 des Port 1 anliegt, mittels DigitalValue zurück liefern
            if(Port_D_Direction == 0){
                //portvalue = io_in16(IN);
                portvalue = (portvalue >> 8)&0xFF;
                DigitalValue = portvalue;

        // Gebe Dualen Wert zurück
                putstring(*DigitalValue);
                break;
    }

    case PC:
        // Port C --> dualen Zahlenwert, bits 7-0 des Port 1 anliegt, mittels DigitalValue zurück liefern

            if(Port_C_Direction == 0){
                break;
    }

    }

    // 1 -> ungültiger BoardHandle
    // 2 -> ungültiger Port

    return 0;
}

BYTE OutputByte(DSCB BoardHandle, BYTE Port, BYTE DigitalValue) {
	
    unsigned long int Steuerwort;
    BYTE Port_A_Direction = Steuerwort & 0b00000001; // PA 0 = 0x90;
    BYTE Port_B_Direction = Steuerwort & 0b00000010; // PB 1 = 0x82;

    switch(Port){

    case PB:
        // Port B --> dualen Zahlenwert, bits 15-8 des Port 0 anliegt, mittels DigitalValue zurück liefern

            if(Port_B_Direction == 0){
             //   putstring("Port B als Eingang für das obere Byte von Port 0 gesetzt\n");
                break;
            }


    case PA:
        // Port A --> dualen Zahlenwert, bits 7-0 des Port 0 anliegt, mittels DigitalValue zurück liefern
            if(Port_A_Direction == 0){
             //   putstring("Port A als Eingang für das untere Byte von Port 0 gesetzt\n");
                break;
            }
    }

    // 1 -> ungültiger BoardHandle
    // 2 -> ungültiger Port
    // 3 -> es wurde versucht etwas auf einen als Eingang konfigurierten Port auszugeben

    return 0; // 0 -> kein Fehler

}

BYTE Free(DSCB BoardHandle) {

    // 1 -> ungültiger BoardHandle
	
    return 0;

}

