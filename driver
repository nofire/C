#include "simuc.h"
#include "io_treiber.h"

#define wait_for_return
//#include "dsclib.h"

typedef struct BHandle_Data {
	BYTE Board_allocated;	// 1=allocated, 0=free
	BYTE Port_A_Direction;	// 1=Output, 0=Input
	BYTE Port_B_Direction;
	BYTE Port_C_Direction;
	BYTE Port_D_Direction;
} BHandle;

unsigned short int portvalue;

BHandle BoardHandle_Data;
DSCB GlobalBoardHandle = &BoardHandle_Data;
BYTE Board_allocated;
BYTE Port_A_Direction; // PA 0 = 0x90;
BYTE Port_B_Direction; // PB 1 = 0x82;
BYTE Port_C_Direction; // PC 2 = 0x88;
BYTE Port_D_Direction; // PD 3 = 0x81;

BYTE Init(DSCB BoardHandle, unsigned long int Steuerwort) {

    /*Ports 0,1,3,4 auslesen*/
    switch(Steuerwort){

        case PA:                                                           // Eingang Port A
            if(Port_A_Direction == (Steuerwort & 0b00000001)){
                io_out16(DIR1,0x0000);
                io_out16(DIR0,0xFFFF);
                Board_allocated  = 1;
                Port_A_Direction = 0;
                Port_B_Direction = 1;
                Port_C_Direction = 1;
                Port_D_Direction = 1;
                break;
        }


        case PB:                                                            // Eingang Port B
            if(Port_A_Direction == (Steuerwort & 0b00000010)){
                io_out16(DIR1,0x0000);
                io_out16(DIR0,0xFFFF);
                Board_allocated  = 1;
                Port_A_Direction = 1;
                Port_B_Direction = 0;
                Port_C_Direction = 1;
                Port_D_Direction = 1;
                break;

            }


        case PC:                                                            // Eingang Port C
            if(Port_A_Direction == (Steuerwort & 0b00000100)){
                io_out16(DIR1,0x0000);
                io_out16(DIR0,0xFFFF);
                Board_allocated  = 1;
                Port_A_Direction = 1;
                Port_B_Direction = 1;
                Port_C_Direction = 0;
                Port_D_Direction = 1;
                break;

            }


        case PD:                                                             // Eingang Port D
            if(Port_A_Direction == (Steuerwort & 0b00001000)){
                io_out16(DIR1,0x0000);
                io_out16(DIR0,0xFFFF);
                Board_allocated  = 1;
                Port_A_Direction = 1;
                Port_B_Direction = 1;
                Port_C_Direction = 1;
                Port_D_Direction = 0;
            break;

            }
        }

    return 0;
}

BYTE InputByte(DSCB BoardHandle, BYTE Port, BYTE *DigitalValue) {
	

    // Port D gelesen wird, so muss InputByte den dualen Zahlenwert,
    // der an den bits 15-8 des Port 1 anliegt,
    // mittels DigitalValue zurück geliefert werden



    // Port C gelesen wird, so muss InputByte den dualen Zahlenwert,
    // der an den bits 7-0 des Port 1 anliegt,
    // mittels DigitalValue zurück geliefert werden

    // Port B gelesen wird, so muss InputByte den dualen Zahlenwert,
    // der an den bits 15-8 des Port 0 anliegt,
    // mittels DigitalValue zurück geliefert werden

    // Port A gelesen wird, so muss InputByte den dualen Zahlenwert,
    // der an den bits 7-0 des Port 0 anliegt,
    // mittels DigitalValue zurück geliefert werden





    // Eingang Port 1
    switch(Port){

    case 0x81:
            if(Port_D_Direction == 0){
                putstring("Port D als Eingang für das obere Byte von Port 1 gesetzt\n");
                portvalue = io_in16(IN);
                portvalue = (portvalue >> 8)&0xFF;
                /*DigitalValue = portvalue;*/
                break;
    }

    case 0x88:
            if(Port_C_Direction == 0){
                putstring("Port C als Eingang für das untere Byte von Port 1 gesetzt\n");
                break;
    }

    }

    // 1 -> ungültiger BoardHandle
    // 2 -> ungültiger Port

    return 0;                           // 0 -> kein Fehler
}

BYTE OutputByte(DSCB BoardHandle, BYTE Port, BYTE DigitalValue) {
	

    switch(Port){

    case 0x82:
            if(Port_B_Direction == 0){
                putstring("Port B als Eingang für das obere Byte von Port 0 gesetzt\n");
                break;
            }

    case 0x90:
            if(Port_A_Direction == 0){
                putstring("Port A als Eingang für das untere Byte von Port 0 gesetzt\n");
                break;
            }
    }

    // 1 -> ungültiger BoardHandle
    // 2 -> ungültiger Port
    // 3 -> es wurde versucht etwas auf einen als Eingang konfigurierten Port auszugeben

    return 0; // 0 -> kein Fehler

}

BYTE Free(DSCB BoardHandle) {

    // 1 -> ungültiger BoardHandle
	
    return 0;                           // 0 -> kein Fehler

}

